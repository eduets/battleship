(()=>{"use strict";class s{length;#s;constructor(s){this.length=s,this.#s=0}hit(){this.#s+=1}isSunk(){return this.#s>=this.length}resetHits(){this.#s=0}}class t{ship=null;isHit=!1;constructor(){}hit(){this.isHit=!0,null!==this.ship&&this.ship.hit()}}class e{#t={};constructor(){}#e(s){this.#t[s]=[]}#i(s){return Object.prototype.hasOwnProperty.call(this.#t,s)}#a(s){let t=!1;return this.#i(s)&&0===this.#t[s].length&&(t=!0),t}#r(s){this.#i(s)&&delete this.#t[s]}on(s,t){this.#i(s)||this.#e(s),this.#t[s].push(t)}off(s,t){if(this.#i(s)){const e=this.#t[s].length;for(let i=0;i<e;i++)if(this.#t[s][i]===t){this.#t[s].splice(i,1);break}this.#a(s)&&this.#r(s)}}offAllInstances(s,t){if(this.#i(s)){for(let e=this.#t[s].length-1;e>=0;e--)this.#t[s][e]===t&&this.#t[s].splice(e,1);this.#a(s)&&this.#r(s)}}emit(s,...t){if(this.#i(s)){const e=this.#t[s].length;for(let i=0;i<e;i++)this.#t[s][i](...t)}}}class i{#d=0;#c=[5,4,3,3,2];#l=[];board=[];eventBus=new e;constructor(){for(const t of this.#c)this.#l.push(new s(t));this.buildBoard()}buildBoard(){this.unsink(),this.board=[];for(let s=0;s<10;s++){this.board.push([]);for(let e=0;e<10;e++)this.board[s].push(new t)}this.placeRandomShips()}placeRandomShips(){for(const s of this.#l){let t=!1;s:for(;!t;){const e=[Math.floor(10*Math.random()),Math.floor(10*Math.random())],i=[Math.random()<.5?0:1,0];0!==i[0]?i[0]=Math.random()<.5?-1:1:i[1]=Math.random()<.5?-1:1;for(let t=0;t<s.length;t++){const s=[e[0]+t*i[0],e[1]+t*i[1]];if(s[0]<0||s[0]>9||s[1]<0||s[1]>9)continue s;if(null!==this.board[s[0]][s[1]].ship)continue s}for(let t=0;t<s.length;t++){const a=[e[0]+t*i[0],e[1]+t*i[1]];this.board[a[0]][a[1]].ship=s}t=!0}}}receiveAttack(s,t){if(!this.board[s][t].isHit)return this.board[s][t].hit(),null!==this.board[s][t].ship?(this.board[s][t].ship.isSunk(),this.board[s][t].ship):(this.missedAttack(),null)}missedAttack(){this.#d+=1}get missedAttacks(){return this.#d}areAllShipsSunk(){let s=!0;for(const t of this.#l)if(!t.isSunk()){s=!1;break}return s}getSquare(s){return this.board[s[0]][s[1]]}unsink(){for(const s of this.#l)s.resetHits()}}class a{isRealPlayer;gameboard;constructor(s){this.isRealPlayer=s,this.gameboard=new i}}class r{squares=[];coords=[];constructor(){}add(s,t){this.squares.push(s),this.coords.push(t)}}class d{static player1;static player2;static currentTurnPlayer;static currentDefendingPlayer;static eventBus=new e;static EVENTS={GAME_OVER:"gameOver",STRATEGIZE:"strategize"};static isGameOver=!1;static#o=null;static initialize(s){this.player1=new a(!0),this.player2=new a(s),this.setTurns(),d.eventBus.on(d.EVENTS.STRATEGIZE,d.strategize)}static setTurns(){this.currentTurnPlayer=this.player1,this.currentDefendingPlayer=this.player2}static attack(s,t){if(this.isGameOver)return null;const e=this.currentDefendingPlayer.gameboard.receiveAttack(s,t);return this.currentDefendingPlayer.gameboard.areAllShipsSunk()?(this.isGameOver=!0,this.eventBus.emit(this.EVENTS.GAME_OVER),e):(null===e&&(this.currentTurnPlayer===this.player1?(this.currentTurnPlayer=this.player2,this.currentDefendingPlayer=this.player1):(this.currentTurnPlayer=this.player1,this.currentDefendingPlayer=this.player2)),e)}static getComputerRandomAvailableCoordinates(){const s=this.player1.gameboard.board,t=[];for(let e=0;e<s.length;e++)for(let i=0;i<s[e].length;i++)s[e][i].isHit||t.push([e,i]);let e=null;return t.length>0&&(e=t[Math.floor(Math.random()*t.length)]),e}static strategize(s,t){null===d.#o&&(d.#o=new r),d.#o.add(s,t)}static analyzeStrategy(s){const t=[],e=[];for(let i=0;i<this.#o.squares.length;i++)this.#o.squares[i].ship!==s&&(t.push(this.#o.squares[i]),e.push(this.#o.coords[i]));this.#o.squares=t,this.#o.coords=e,0===this.#o.squares.length&&(this.#o=null)}static getComputerSmartCoordinates(){if(null===this.#o)return this.getComputerRandomAvailableCoordinates();{const s=[];let t=[];if(1===this.#o.squares.length){const s=this.#o.coords[0];t=[[s[0],s[1]-1],[s[0]+1,s[1]],[s[0],s[1]+1],[s[0]-1,s[1]]]}else if(this.#o.coords[0][0]===this.#o.coords[1][0]){let s=this.#o.coords[0][1],e=this.#o.coords[0][1];for(let t=1;t<this.#o.coords.length;t++)this.#o.coords[t][1]<s&&(s=this.#o.coords[t][1]),this.#o.coords[t][1]>e&&(e=this.#o.coords[t][1]);t.push([this.#o.coords[0][0],s-1]),t.push([this.#o.coords[0][0],e+1])}else{let s=this.#o.coords[0][0],e=this.#o.coords[0][0];for(let t=1;t<this.#o.coords.length;t++)this.#o.coords[t][0]<s&&(s=this.#o.coords[t][0]),this.#o.coords[t][0]>e&&(e=this.#o.coords[t][0]);t.push([s-1,this.#o.coords[0][1]]),t.push([e+1,this.#o.coords[0][1]])}for(const e of t)e[0]>=0&&e[0]<10&&e[1]>=0&&e[1]<10&&(this.player1.gameboard.getSquare(e).isHit||s.push(e));if(0===s.length){t=[];for(let s=1;s<this.#o.coords.length;s++){const e=this.#o.coords[s],i=[e[0],e[1]-1],a=[e[0]+1,e[1]],r=[e[0],e[1]+1],d=[e[0]-1,e[1]];t=t.concat([i,a,r,d])}for(const e of t)e[0]>=0&&e[0]<10&&e[1]>=0&&e[1]<10&&(this.player1.gameboard.getSquare(e).isHit||s.push(e))}return s[Math.floor(Math.random()*s.length)]}}static unsink(){this.player1.gameboard.unsink(),this.player2.gameboard.unsink()}static resetStrategy(){this.#o=null}}const c='<div class="graveyard hidden"> <div class="tomb" data-length="5"> <div></div> <div></div> <div></div> <div></div> <div></div> </div> <div class="tomb" data-length="4"> <div></div> <div></div> <div></div> <div></div> </div> <div class="tomb" data-length="3"> <div></div> <div></div> <div></div> </div> <div class="tomb" data-length="3"> <div></div> <div></div> <div></div> </div> <div class="tomb" data-length="2"> <div></div> <div></div> </div> </div> ';class l{static#n;static#v;static#h;static#u;static#m;static boardSelf;static boardEnemy;static#p;static#g;static#y;static#q;static startButton;static#S;static eventBus=new e;static EVENTS={BOARD_CLICKED:"boardClicked",RANDOMIZE:"randomize",START:"start"};static initialize(s){this.#n=s,this.#v=this.#n.querySelector(".boards"),this.#h=this.#E('<div class="board"> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> <div class="square"></div> </div> '),this.#u=this.#E('<div class="info-options"> <div class="randomize"> <button id="randomize-button">RANDOMIZE</button> </div> <div class="message hidden">YOU LOSE!</div> <div class="start"> <button id="start-button">START</button> </div> </div> '),this.boardSelf=this.#h.cloneNode(!0).firstElementChild,this.boardSelf.classList.add("self"),this.#v.appendChild(this.boardSelf),this.#p=this.#E(c),this.#g=this.#p.cloneNode(!0).firstElementChild,this.#v.appendChild(this.#g),this.#m=this.#u.cloneNode(!0).firstElementChild,this.#v.appendChild(this.#m),this.#p=this.#E(c),this.#y=this.#p.cloneNode(!0).firstElementChild,this.#v.appendChild(this.#y),this.boardEnemy=this.#h.cloneNode(!0).firstElementChild,this.boardEnemy.classList.add("enemy"),this.#v.appendChild(this.boardEnemy),this.#S=this.#n.querySelector(".message"),this.#q=this.#n.querySelector("#randomize-button"),this.startButton=this.#n.querySelector("#start-button"),this.#q.addEventListener("click",(s=>{this.eventBus.emit(this.EVENTS.RANDOMIZE)})),this.startButton.addEventListener("click",(s=>{this.eventBus.emit(this.EVENTS.START)}));for(const s of this.boardEnemy.children)s.classList.add("undiscovered");this.setUnclickable(this.boardEnemy)}static#E(s){const t=this.#n.createElement("template");return t.innerHTML=s.trim(),t.content}static setClickable(s){s.addEventListener("click",l.boardClicked,{capture:!0}),s.classList.remove("unclickable")}static setUnclickable(s){s.removeEventListener("click",l.boardClicked,{capture:!0}),s.classList.add("unclickable")}static boardClicked(s){if(s.target!==l.boardEnemy){if(!s.target.classList.contains("undiscovered"))return;const t=Array.from(l.boardEnemy.children).indexOf(s.target);s.target.classList.remove("undiscovered");const e=Math.floor(t/10),i=t%10;l.eventBus.emit(l.EVENTS.BOARD_CLICKED,e,i,s.target)}}static setSquareHit(s){s.classList.add("hit")}static setSquareMiss(s){s.classList.add("miss")}static renderShips(s,t){for(let e=0;e<t.length;e++)for(let i=0;i<t[e].length;i++){const a=t[e][i],r=10*e+i;s.children[r].classList.remove("ship"),s.children[r].classList.remove("curve-left"),s.children[r].classList.remove("curve-right"),s.children[r].classList.remove("curve-top"),s.children[r].classList.remove("curve-bottom"),null!==a.ship&&(s.children[r].classList.add("ship"),this.manageAdjacency(a,t,s,r,e,i))}}static manageAdjacency(s,t,e,i,a,r){const d=[[a,r-1],[a+1,r],[a,r+1],[a-1,r]];let c=0,l=!1,o=!1,n=!1,v=!1;for(let e=0;e<d.length;e++){const i=d[e];i[0]>=0&&i[0]<10&&i[1]>=0&&i[1]<10&&t[i[0]][i[1]].ship===s.ship&&(c+=1,0===e?l=!0:1===e?o=!0:2===e?n=!0:3===e&&(v=!0))}1===c&&(l?e.children[i].classList.add("curve-bottom"):o?e.children[i].classList.add("curve-left"):n?e.children[i].classList.add("curve-top"):v&&e.children[i].classList.add("curve-right"))}static getSelfSquareElement(s,t){const e=10*s+t;return this.boardSelf.children[e]}static showGraveyards(){const s=this.#n.querySelectorAll(".graveyard");for(const t of s)t.classList.remove("hidden")}static hideGraveyards(){const s=this.#n.querySelectorAll(".graveyard");for(const t of s)t.classList.add("hidden")}static showRandomize(){this.#q.classList.remove("hidden")}static hideRandomize(){this.#q.classList.add("hidden")}static showInfoOptions(){this.#m.classList.remove("hidden")}static hideInfoOptions(){this.#m.classList.add("hidden")}static setContinueText(){this.startButton.textContent="CONTINUE"}static setStartText(){this.startButton.textContent="START"}static sunkShip(s,t){const e=t.querySelectorAll(`[data-length="${s.length}"]`);let i=0;e[0].classList.contains("sunk")&&(i=e.length-1),e[i].classList.add("sunk")}static sunkSelf(s){this.sunkShip(s,this.#g)}static sunkEnemy(s){this.sunkShip(s,this.#y)}static showVictoryMessage(){this.#S.textContent="YOU WIN!",this.#S.classList.remove("hidden")}static showDefeatMessage(){this.#S.textContent="YOU LOSE!",this.#S.classList.remove("hidden")}static hideMessage(){this.#S.classList.add("hidden")}static clearBoard(s,t){for(let e=0;e<s.children.length;e++)s.children[e].classList.remove("ship"),s.children[e].classList.remove("hit"),s.children[e].classList.remove("miss"),t&&s.children[e].classList.add("undiscovered")}static clearBoards(){this.clearBoard(this.boardSelf,!1),this.clearBoard(this.boardEnemy,!0)}static clearGraveyard(s){for(let t=0;t<s.children.length;t++)s.children[t].classList.remove("sunk")}static clearGraveyards(){this.clearGraveyard(this.#g),this.clearGraveyard(this.#y)}}class o{static COMPUTER_REACTION_TIME=500;static{this.#f()}static#f(){d.initialize(!1),d.eventBus.on(d.EVENTS.GAME_OVER,o.gameOver),l.initialize(document),l.eventBus.on(l.EVENTS.BOARD_CLICKED,o.boardClicked),l.renderShips(l.boardSelf,d.player1.gameboard.board),l.eventBus.on(l.EVENTS.RANDOMIZE,o.randomize),l.eventBus.on(l.EVENTS.START,o.start)}static gameOver(){l.setUnclickable(l.boardEnemy),l.showInfoOptions(),d.currentTurnPlayer===d.player1?l.showVictoryMessage():l.showDefeatMessage(),l.hideRandomize(),l.setContinueText()}static boardClicked(s,t,e){let i=null;if(i=d.attack(s,t),null!==i)return i.isSunk()&&l.sunkEnemy(i),void l.setSquareHit(e);l.setSquareMiss(e),l.setUnclickable(l.boardEnemy),setTimeout(o.computerAttack,o.COMPUTER_REACTION_TIME)}static computerAttack(){let s=null;const t=d.getComputerSmartCoordinates();s=d.attack(...t);const e=l.getSelfSquareElement(...t);null!==s?l.setSquareHit(e):l.setSquareMiss(e),null!==s?(d.eventBus.emit(d.EVENTS.STRATEGIZE,d.player1.gameboard.getSquare(t),t),s.isSunk()&&(d.analyzeStrategy(s),l.sunkSelf(s)),d.isGameOver||setTimeout(o.computerAttack,o.COMPUTER_REACTION_TIME)):d.isGameOver||l.setClickable(l.boardEnemy)}static randomize(){d.player1.gameboard.buildBoard(),l.renderShips(l.boardSelf,d.player1.gameboard.board)}static start(){"CONTINUE"!==l.startButton.textContent?(l.setClickable(l.boardEnemy),l.showGraveyards(),l.hideInfoOptions(),d.isGameOver=!1):(l.setStartText(),l.hideMessage(),l.showRandomize(),l.clearBoards(),l.clearGraveyards(),l.hideGraveyards(),d.resetStrategy(),d.setTurns(),d.player1.gameboard.buildBoard(),d.player2.gameboard.buildBoard(),l.renderShips(l.boardSelf,d.player1.gameboard.board))}}})();